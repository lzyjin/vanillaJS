<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <!--
    <div id="foo">Hello <span>world!</span></div>

    <script>
        // #foo 요소의 컨텐츠 영역 내의 HTML 마크업을 문자열로 취득한다.
        console.log(document.getElementById('foo').innerHTML); // Hello <span>world!</span>
        console.log(document.getElementById('foo').textContent); // Hello world!

        // HTML이 파싱되어 요소 노드의 자식 노드로 DOM에 반영된다.
        document.getElementById('foo').innerHTML = 'Hi <span>there!</span>';
    </script>
    -->


    <!--
    <ul id="fruits">
        <li class="apple">Apple</li>
    </ul>

    <script>
        const $fruits = document.getElementById('fruits');

        // 노드 추가
        $fruits.innerHTML += '<li class="banana">Banana</li>';

        // 노드 교체
        $fruits.innerHTML = '<li class="orange">Orange</li>';

        // 노드 삭제
        $fruits.innerHTML = '';
    </script>
    -->



    <!-- innerHTML 프로퍼티로 스크립트 태그를 삽입하여 자바스크립트가 실행되도록 하는 예제를 살펴보자. -->
    <!--
    <div id="foo">Hello</div>

    <script>
        // innerHTML 프로퍼티로 스크립트 태그를 삽입하여 자바스크립트가 실행되도록 한다.
        // HTML5는 innerHTML 프로퍼티로 삽입된 script 요소 내의 자바스크립트 코드를 실행하지 않는다.
        document.getElementById('foo').innerHTML = '<script>alert(document.cookie)</script>';
    </script>
    -->


    <!--
    HTML5는 innerHTML 프로퍼티로 삽입된 script 요소 내의 자바스크립트 코드를 실행하지 않는다.
    따라서 HTML5를 지원하는 브라우저에서 위 예제는 동작하지 않는다.
    하지만 script 요소 없이도 크로스 사이트 스크립팅 공격은 가능하다.
    다음의 간단한 크로스 사이트 스크립팅 공격은 모던 브라우저에서도 동작한다.
    -->

    <!--
    <div id="foo">Hello</div>

    <script>
        // 에러 이벤트를 강제로 발생시켜서 자바스크립트 코드가 실행되도록 한다.
        document.getElementById('foo').innerHTML = '<img src="x" onerror="alert(document.cookie)">';
    </script>
    -->



    <!-- innerHTML의 또 다른 단점 -->
    <!-- innerHTML 프로퍼티에 HTML 마크업 문자열을 할당하면 유지되어도 좋은 기존의 자식 노드까지 모두 제거하고
        다시 처음부터 새롭게 자식 노드를 생성하여 DOM에 반영한다. -->
    <!--
    <ul id="fruits">
        <li class="apple">Apple</li>
    </ul>

    <script>
        const $fruits = document.getElementById('fruits');

        // 노드 추가
        $fruits.innerHTML += '<li class="banana">Banana</li>';
        // 위 코드는 다음 코드의 축약 표현이다.
        // $fruits.innerHTML = $fruits.innerHTML + '<li class="banana">Banana</li>';
        // $fruits.innerHTML = '<li class="apple">Apple</li>' + '<li class="banana">Banana</li>'
    </script>
    -->

    <!--
        위 예제는 #fruits 요소에 자식 요소 li.banana를 추가한다.
        이때 #fruits 요소의 자식 요소 li.apple은 아무런 변경이 없으므로 다시 생성할 필요가 없다.
        다만 새롭게 추가할 li.banana 요소 노드만 생성하여 #fruits 요소의 자식 요소로 추가하면 된다.
        위 예제는 얼핏 보면 그렇게 동작할 것처럼 보이지만,
        ❕ 사실은 #fruits 요소의 모든 자식 노드(li.apple)를 제거하고 새롭게 요소 노드 li.apple과 li.banana를 생성하여 #fruits 요소의 자식 요소로 추가한다.

        이처럼 innerHTML 프로퍼티에 HTML 마크업 문자열을 할당하면 유지되어도 좋은 기존의 자식 노드까지 모두 제거하고
        다시 처음부터 새롭게 자식 노드를 생성하여 DOM에 반영한다.
    -->

    <!--
        innerHTML 프로퍼티의 단점은 이뿐만이 아니다.
        innerHTML 프로퍼티는 새로운 요소를 삽입할 때 삽입될 위치를 지정할 수 없다는 단점도 있다.
    -->


    <ul id="fruits">
        <li class="apple">Apple</li>
        <li class="banana">Banana</li>
    </ul>

    <!--
        li.apple 요소와 li.orange 요소 사이에 새로운 요소를 삽입하고 싶은 경우
        innerHTML 프로퍼티를 사용하면 삽입 위치를 지정할 수 없다.
        이처럼 innerHTML 프로퍼티는 복잡하지 않은 요소를 새롭게 추가할 때 유용하지만
        기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입해야 할 때는 사용하지 않는 것이 좋다.
    -->
</body>
</html>
